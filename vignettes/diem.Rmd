---
title: "Cleaning snRNA-seq data using DIEM"
author: "Marcus Alvarez"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Cleaning snRNA-seq data using DIEM}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

# 1. Introduction

The `diem` package provides a lightweight solution to clean up single-cell 
data during the pre-processing step. The purpose 
of `diem` is to remove droplets that contain extranuclear or extracellular 
RNA. `diem` is designed for droplet-based single-nucleus and 
single-cell RNA-seq and has been tested on 10X Chromium data.

This tutorial will use the publicly available 10X single-nucleus RNA-seq 
data that was generated from fresh mouse brain tissue. We will use a 
subset of the data that is available with the package. The full data 
set is available [here](https://support.10xgenomics.com/single-cell-gene-expression/datasets/2.1.0/nuclei_2k).

# 2. Data input

`diem` takes as input the raw counts from a droplet-based single-cell 
experiment such as from 10X. The raw counts are stored in a 
column-wise sparse matrix using the implementation from the R package 
[Matrix](https://CRAN.R-project.org/package=Matrix). 
Furthermore, `diem` takes advantage of the matrix manipulation 
functions in the `Matrix` package to speed up computations. The R 
object that wraps data access and the `diem` functions is the 
`SCE` object. It is important to note here that `diem` works best 
when all droplets generated by the experiment are included, even 
those with only 1 read mapping to a gene. They provide extensive 
information on the RNA profile of the background distribution.

If you have 10X data that has been aligned with 
[CellRanger](https://support.10xgenomics.com/single-cell-gene-expression/software/pipelines/latest/what-is-cell-ranger), 
then the raw data will be stored in `outs/raw_feature_bc_matrix` in 
the output directory (for CellRanger v3). We provide a convenience function 
`read_10x` that can read the 10X output into a sparse Matrix.

```{r}
library(diem)

# In the diem directory
counts <- read_10x("../tests/testdata/")
dim(counts)
class(counts)
```

This function reads in the counts present in the `tests/testdata` 
directory into a sparse matrix. This subset of the mouse brain raw data 
from 10X contains 1,001 genes and 2,457 droplets.

The raw counts in a sparse matrix forms the starting point for 
pre-processing with `diem`.

## 2.1 Creating an SCE object

The SCE object is created first:

```{r}
mb_small <- create_SCE(counts, name="MouseBrain")
dim(mb_small)
class(mb_small)
```

The SCE object `mb_small` stores the counts as well as the meta data 
on the droplets:

```{r}
drop_data <- droplet_data(mb_small)
head(drop_data)
summary(drop_data)
```

## 2.2 Plotting quality metrics

Useful diagnostics for assessing droplets include the percent 
of reads that align to the mitochondrial genome, in addition to 
percent that align the nuclear-localized MALAT1. We can generate 
this using the following:

```{r}
mt_genes <- grep(pattern = "^mt-", x = rownames(mb_small@gene_data), 
                 ignore.case = TRUE, value = TRUE)
mb_small <- get_gene_pct(x = mb_small, genes = mt_genes, name = "pct.mt")
genes <- grep(pattern = "^malat1$", x = rownames(mb_small@gene_data), 
              ignore.case = TRUE, value = TRUE)
mb_small <- get_gene_pct(x = mb_small, genes = genes, name = "MALAT1")
drop_data <- droplet_data(mb_small)
summary(drop_data)
```

We plot the distribution of reads and MT%.

```{r, fig.width=14, fig.height=14}
drop_data <- droplet_data(mb_small, min_counts = 100)
datf <- drop_data
par(mfrow=c(2,2))
plot(datf$total_counts, datf$n_genes, pch = 16,
     xlab="Total Counts", ylab="Number Genes")
plot(datf$n_genes, datf$pct.mt, pch = 16, 
     xlab="Number Genes", ylab="MT%")
plot(datf$n_genes, datf$MALAT1, pch = 16, 
     xlab="Number Genes", ylab="MALAT1%")
plot(datf$pct.mt, datf$MALAT1, pch = 16, 
     xlab="MT%", ylab="MALAT1%")
```

The data suggests we can separate out 2 clusters, consisting of one 
low count/high MT% cluster, and one high count/low MT% cluster.

# 3. Running DIEM

The following outlines the steps involved in `diem`:

1. Speciyfing the test set and the debris set.
2. Running PCA on test set
2. Running k-means on the PCs to initialize the clusters.
4. Running a EM to estimate the parameters of the Dirichlet-multinomial 
  mixture model.
5. Classifying droplets based on their likelihood.

## 3.1 Specifying test and debris droplets

We first specify which droplets we would like to fix as debris to 
guide the semi-supervised clustering. We specify these droplets 
by setting a count threshold where droplets with less than this 
threshold are fixed as debris. We then classify droplets with at 
least this many counts.
It is helpful to use the above plots and a barcode rank plot 
to determine the cutoff for fixing the debris

```{r}
barcode_rank_plot(mb_small, title = "MouseBrain")
```

Since this is only a subset, the tail of the low-count droplets in the 
barcode-rank plot is much smaller. Typical data sets can have 
tens to hundreds of thousands of droplets more than what is shown here.

The choice of the cutoff to fix debris and classify droplets is somewhat
arbitrary and depends on subjective interpretation of what will likely 
be included in the debris. The better the cutoff, the better `diem` is 
able to estimate the background RNA distribution.
However, setting the cutoff too high can result in
excluding droplets that contain nuclei or cells, while setting the
cutoff too low can result in losing information and misclassifying
debris as a cell type. The default is to set the test set as those 
with at least 100 counts.

```{r}
mb_small <- set_debris_test_set(mb_small, min_counts = 100)
length(mb_small@test_set)
length(mb_small@bg_set)
```

## 3.2 Running PCA on the test set

In order to initialize the parameters, we run PCA and then k-means 
on these PCs. We first select the 2,000 most variable genes from the 
expressed genes. 

We define expressed genes as those with a counts per million (CPM) 
greater than 0. This can be set to a higher value to 
speed up computations

```{r}
mb_small <- filter_genes(mb_small, cpm_thresh = 0)
genes <- gene_data(mb_small)
summary(genes)
```

After filtering genes, we run PCA

```{r}
mb_small <- get_pcs(mb_small, 
                    n_var_genes = 2000)
```

This uses the top 2,000 variable genes to run PCA. We define 
variable genes after taking into account the relationship 
between the mean gene expression and the variance. We do so 
by running loess regression of the log variance against the 
log mean. The standardized variances are the residuals of the 
actual variance subtracted by the fitted variance.

## 3.3 Initializing clusters

Before fitting the mixture model, we need to 
provide initialized values for the parameters. To do this, we 
run k-means on the principal components of the data to cluster the 
droplets. Then, parameters are estimated via maximum likelihood 
for each cluster to initialize them.
Since k-means may converge to a local optimum, we run the algorithm
`n_start` times with different random initializations, allowing
`k_iter` iterations. The run with the lowest total within sum of 
squares is selected.

```{r}
mb_small <- init(mb_small,
                 k_init = 30, 
                 iter.max_init = 15, 
                 nstart_init = 30, 
                 min_size_init = 10, 
                 seedn = 1)
```

The `k_init = 30` says to initialize k-means with 30 centers, while 
the `min_size_init = 10` says to take clusters with less than 10 
droplets and assign them to the next closest cluster. The 
`iter.max_init = 15` and `nstart_init = 30` are parameters for the 
k-means and specify to run k-means 30 times and pick the best run. 
The `iter.max_init` says each run can have at most 15 iterations.
We run multiple starts because k-means may converge to a local optimum. 
The run with the lowest total within sum of 
squares is selected.

As the test set likely includes droplets containing ambient RNA, some 
of the initialized clusters are likely to originate from the 
background. We therefore developed a strategy to estimate a 
likelihood-based distance to the background distribution and 
remove clusters with a distance below a certain threshold. We call the 
`get_dist` function

```{r}
mb_small <- get_dist(mb_small)
d <- distances(mb_small)
```

The distance values are scaled so that the maximum takes a value of 1. 
We must then choose a threshold to remove clusters that have a distance 
below it. It is helpful to look at the distribution of the distances 
against the average total counts

```{r}
plot_dist(mb_small, alpha=.8)
```

Looking at the distribution of distance values, we notice a somewhat 
bimodal pattern, where we can select a value between 0.4 and 0.6. Here 
we choose 0.5, but we note the default is 0.1 to be careful so as to 
not remove cell types.

```{r}
mb_small <- rm_close(mb_small, fltr = 0.1)
```

After removing small clusters and those that lie close to the background 
distribution, we are left with 7 cell types and 1 debris cluster. 
Now that we have the number of mixtures and their initializations, we can 
run EM to estimate the parameters and classify the droplets.

## 3.4 Running EM

Use the `run_em` function to estimate the parameters of the 
Dirichlet-multinomial mixture. Note that we iteratively perform 
additional rounds of cluster removal until only likely cell types 
are left. We again use the `fltr` parameter to specify this 
threshold.

```{r}
mb_small <- run_em(mb_small, fltr = 0.5)
drop_data <- droplet_data(mb_small)
summary(drop_data)
```

After running EM, we see an additional 3 clusters are removed because 
they are too close to the background. After a second EM, the procedure 
is finished. We are left with 297 clean droplets and removed 1,455.


```{r}
mb_small <- call_targets(mb_small, 
                         pp_thresh = 0.95, 
                         min_genes = 100)
clean_ids <- get_clean_ids(mb_small)
length(clean_ids)
debris_ids <- get_removed_ids(mb_small, min_genes = 100)
length(debris_ids)
drop_data <- droplet_data(mb_small)
dd_test <- droplet_data(mb_small, type = "test")
dd_clean <- droplet_data(mb_small, type = "clean")
dd_debris <- droplet_data(mb_small, type = "debris")
```

This shows that droplets that pass filtering tend to have higher 
total counts and lower MT%. Plotting the counts against MT% and 
coloring by call

```{r}
library(ggplot2)
dd_test <- droplet_data(mb_small, type = "test")
ggplot(dd_test, aes(x = total_counts, y = pct.mt, color = Call)) + 
geom_point() + 
theme_minimal() + 
scale_x_log10() + 
xlab("Total Counts") + ylab("MT%")
```

We see the filtered droplets  have higher counts and 
lower percentages of mitochondrial reads. DIEM removed the cluster  
of higher count droplets with high percent mitochondrial reads.

## 4 Changing the filter threshold

Above we used a filter threshold of 0.5 as we saw a nice separation 
between low count and high count clusters. We now illustrate the 
effect of using a lower threshold value of 0.1.

```{r}
mb_small <- init(mb_small,
                 k_init = 30, 
                 seedn = 1)
mb_small <- get_dist(mb_small)
mb_small <- rm_close(mb_small, fltr = 0.1)
mb_small <- run_em(mb_small, fltr = 0.1)


mb_small <- call_targets(mb_small, 
                         pp_thresh = 0.95, 
                         min_genes = 100)
clean_ids <- get_clean_ids(mb_small)
length(clean_ids)
debris_ids <- get_removed_ids(mb_small, min_genes = 100)
length(debris_ids)
```

Using this lower threshold, we now have 393 passing filtering, more than 
the 297 that passed using a threshold of 0.5.

```{r}
library(ggplot2)
dd_test <- droplet_data(mb_small, type = "test")
ggplot(dd_test, aes(x = total_counts, y = pct.mt, color = Call)) + 
geom_point() + 
theme_minimal() + 
scale_x_log10() + 
xlab("Total Counts") + ylab("MT%")
```

We also see that droplets with higher percent mitochondrial reads pass 
filtering.

# 5. Downstream analysis

`diem` filtering provided a set of droplets we can use for downstream 
analysis. We can extract the droplets passing `diem` filtering as well 
as the counts.

```{r}
counts <- raw_counts(mb_small)
clean_ids <- get_clean_ids(mb_small)
counts_clean <- counts[,clean_ids]
dim(counts_clean)
```

As `diem` also clusters the droplets, one can use this for analyses of 
cell types. They are stored in the `droplet_data` data frame.

```{r}
dd_clean <- droplet_data(mb_small, type = "clean")
table(dd_clean[,"Cluster"])
```

Since contamination of droplets with ambient RNA is not binary but 
continuous, we also provide the ratio of log likelihoods of 
debris over cell types in the `DebrisLogOdds` column of the 
`droplet_data` data frame. This can be used as a covariate in, for 
example, PCA and clustering. Higher values indicate the droplet is 
more similar to the debris.

```{r}
dd_clean <- droplet_data(mb_small, type = "clean")
summary(dd_clean[,"DebrisLogOdds"])
cor(dd_clean[,"DebrisLogOdds"], dd_clean[,"n_genes"])
```

We also provide a convenience function for converting to a Seurat 
object. Arguments to the `CreateSeuratObject` function can be passed 
at the end of the function call, such as `min.features` here.

```{r, eval = FALSE}
seur <- convert_to_seurat(mb_small, 
                          targets = TRUE, 
                          meta = TRUE, 
                          min.features = 100)
dim(seur)
head(seur@meta.data)
```

# 7. Wrapper function

We provide a convenience function that calls many of these functions at 
once. The workflow is as follows

```{r, eval = FALSE}
mb_small <- diem(mb_small, min_counts = 100, cpm_thresh = 0, 
        n_var_genes = 2000, k_init = 30, fltr = 0.5)
mb_small <- call_targets(mb_small, 
                         pp_thresh = 0.95, 
                         min_genes = 100)

```

The results are the same as the steps individually.

