---
title: "Cleaning snRNA-seq data using DIEM"
author: "Marcus Alvarez"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Cleaning snRNA-seq data using DIEM}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

# 1. Introduction

The `diem` package provides a lightweight solution to clean up single-cell 
data during the pre-processing step. The purpose 
of `diem` is to remove droplets that contain extranuclear or extracellular 
RNA. `diem` is designed for droplet-based single-nucleus and 
single-cell RNA-seq and has been tested on 10X Chromium data.

This tutorial will use the publicly available 10X single-nucleus RNA-seq 
data that was generated from fresh mouse brain tissue. We will use a 
subset of the data that is available with the package. The full data 
set is available [here](https://support.10xgenomics.com/single-cell-gene-expression/datasets/2.1.0/nuclei_2k).

# 2. Data input

`diem` takes as input the raw counts from a droplet-based single-cell 
experiment such as from 10X. The raw counts are stored in a 
column-wise sparse matrix using the implementation from the R package 
[Matrix](https://CRAN.R-project.org/package=Matrix). 
Furthermore, `diem` takes advantage of the matrix manipulation 
functions in the `Matrix` package to speed up computations. The R 
object that wraps data access and the `diem` functions is the 
`SCE` object. It is important to note here that `diem` works best 
when all droplets generated by the experiment are included, even 
those with only 1 read mapping to a gene. They provide extensive 
information on the RNA profile of the background distribution.

If you have 10X data that has been aligned with 
[CellRanger](https://support.10xgenomics.com/single-cell-gene-expression/software/pipelines/latest/what-is-cell-ranger), 
then the raw data will be stored in `outs/raw_feature_bc_matrix` in 
the output directory (for CellRanger v3). We provide a convenience function 
`read_10x` that can read the 10X output into a sparse Matrix.

```{r}
library(diem)

# In the diem directory
counts <- read_10x("../tests/testdata/")
dim(counts)
class(counts)
```

This function reads in the counts present in the `tests/testdata` 
directory into a sparse matrix. This subset of the mouse brain raw data 
from 10X contains 501 genes and 1,200 droplets.

The raw counts in a sparse matrix forms the starting point for 
pre-processing with `diem`.

## 2.1 Creating an SCE object

The SCE object is created first:

```{r}
mb_small <- create_SCE(counts, name="MouseBrain")
dim(mb_small)
class(mb_small)
```

The SCE object `mb_small` stores the counts as well as the meta data 
on the droplets:

```{r}
drop_data <- droplet_data(mb_small)
head(drop_data)
summary(drop_data)
```

## 2.2 Plotting quality metrics

Useful diagnostics for assessing droplets include the percent 
of reads that align to the mitochondrial genome, in addition to 
percent that align the nuclear-localized MALAT1. We can generate 
this using the following:

```{r}
mt_genes <- grep(pattern = "^mt-", x = rownames(mb_small@gene_data), 
                 ignore.case = TRUE, value = TRUE)
mb_small <- get_gene_pct(x = mb_small, genes = mt_genes, name = "pct.mt")
genes <- grep(pattern = "^malat1$", x = rownames(mb_small@gene_data), 
              ignore.case = TRUE, value = TRUE)
mb_small <- get_gene_pct(x = mb_small, genes = genes, name = "MALAT1")
drop_data <- droplet_data(mb_small)
summary(drop_data)
```

We plot the distribution of reads and MT%.

```{r, fig.width=14, fig.height=14}
drop_data <- droplet_data(mb_small)
datf <- drop_data
par(mfrow=c(2,2))
plot(datf$total_counts, datf$n_genes, pch = 16,
     xlab="Total Counts", ylab="Number Genes")
plot(datf$n_genes, datf$pct.mt, pch = 16, 
     xlab="Number Genes", ylab="MT%")
plot(datf$n_genes, datf$MALAT1, pch = 16, 
     xlab="Number Genes", ylab="MALAT1%")
plot(datf$pct.mt, datf$MALAT1, pch = 16, 
     xlab="MT%", ylab="MALAT1%")
```

The data suggests we can separate out 2 clusters, consisting of one 
low count/high MT% cluster, and one high count/low MT% cluster.

# 3. Running DIEM

The following outlines the steps involved in `diem`:

1. Speciyfing the test set and the debris set.
2. Running PCA on test set
2. Running k-means on the PCs to initialize the clusters.
4. Running a EM to estimate the parameters of the Dirichlet-multinomial 
  mixture model.
5. Classifying droplets based on their likelihood.

## 3.1 Specifying test and debris droplets

We first specify which droplets we would like to fix as debris to 
guide the semi-supervised clustering. We specify these droplets 
by setting a count threshold where droplets with less than this 
threshold are fixed as debris. We then classify droplets with at 
least this many counts.
It is helpful to use the above plots and a barcode rank plot 
to determine the cutoff for fixing the debris

```{r}
barcode_rank_plot(mb_small, title = "MouseBrain")
```

Since this is only a subset, the tail of the low-count droplets in the 
barcode-rank plot is much smaller. Typical data sets can have 
tens to hundreds of thousands of droplets more than what is shown here.

The choice of the cutoff to fix debris and classify droplets is somewhat
arbitrary and depends on subjective interpretation of what will likely 
be included in the debris. The better the cutoff, the better `diem` is 
able to estimate the background RNA distribution.
However, setting the cutoff too high can result in
excluding droplets that contain nuclei or cells, while setting the
cutoff too low can result in losing information and misclassifying
debris as a cell type. The default is to set the test set as those 
with at least 100 counts. Here we set it to 10 since this is a subset.

```{r}
mb_small <- set_debris_test_set(mb_small, min_counts = 10)
length(mb_small@test_set)
length(mb_small@bg_set)
```

## 3.2 Running PCA on the test set

In order to initialize the parameters, we run PCA and then k-means 
on these PCs.

We define expressed genes as those with a counts per million (CPM) 
greater than 0. This can be set to a higher value to 
speed up computations

```{r}
mb_small <- filter_genes(mb_small, cpm_thresh = 0)
genes <- gene_data(mb_small)
summary(genes)
```

After filtering genes, we run PCA. Although the default is to 
select the top 2,00 variable genes, we select the top 250 
most variable genes here since this is a subset

```{r}
mb_small <- get_pcs(mb_small, 
                    n_var_genes = 250)
```

This uses the top 250 variable genes to run PCA. We define 
variable genes after taking into account the relationship 
between the mean gene expression and the variance. We do so 
by running loess regression of the log variance against the 
log mean. The standardized variances are the residuals of the 
actual variance subtracted by the fitted variance.

## 3.3 Initializing clusters

Before fitting the mixture model, we need to 
provide initialized values for the parameters. To do this, we 
run k-means on the principal components of the data to cluster the 
droplets. Then, parameters are estimated via maximum likelihood 
for each cluster to initialize them.
Since k-means may converge to a local optimum, we run the algorithm
`n_start` times with different random initializations, allowing
`k_iter` iterations. The run with the lowest total within sum of 
squares is selected.

```{r}
mb_small <- init(mb_small,
                 k_init = 30, 
                 iter.max_init = 15, 
                 nstart_init = 30, 
                 min_size_init = 10, 
                 seedn = 1)
```

The `k_init = 30` says to initialize k-means with 30 centers, while 
the `min_size_init = 10` says to take clusters with less than 10 
droplets and assign them to the next closest cluster. The 
`iter.max_init = 15` and `nstart_init = 30` are parameters for the 
k-means and specify to run k-means 30 times and pick the best run. 
The `iter.max_init` says each run can have at most 15 iterations.
We run multiple starts because k-means may converge to a local optimum. 
The run with the lowest total within sum of 
squares is selected.

Now that we have the number of mixtures and their initializations, we can 
run EM to estimate the parameters and classify the droplets.

## 3.4 Running EM

Use the `run_em` function to estimate the parameters of the 
Dirichlet-multinomial mixture

```{r}
mb_small <- run_em(mb_small)
mb_small <- assign_clusters(mb_small)
mb_small <- estimate_dbr_score(mb_small)
drop_data <- droplet_data(mb_small)
summary(drop_data)
```

We see the filtered droplets  have higher counts and 
lower percentages of mitochondrial reads. DIEM removed the cluster  
of higher count droplets with high percent mitochondrial reads.

# 5. Downstream analysis

`diem` filtering provided a set of droplets we can use for downstream 
analysis. We can extract the droplets passing `diem` filtering as well 
as the counts.

```{r}
counts <- raw_counts(mb_small)
```

As `diem` also clusters the droplets, one can use this for analyses of 
cell types. They are stored in the `droplet_data` data frame.

Since contamination of droplets with ambient RNA is not binary but 
continuous, we also provide the ratio of log likelihoods of 
debris over cell types in the `DebrisLogOdds` column of the 
`droplet_data` data frame. This can be used as a covariate in, for 
example, PCA and clustering. Higher values indicate the droplet is 
more similar to the debris.


We also provide a convenience function for converting to a Seurat 
object. Arguments to the `CreateSeuratObject` function can be passed 
at the end of the function call, such as `min.features` here.


# 7. Wrapper function

We provide a convenience function that calls many of these functions at 
once. The workflow is as follows

```{r, eval = FALSE}
mb_small <- diem(mb_small, min_counts = 10, cpm_thresh = 0, 
        n_var_genes = 250, k_init = 30)
mb_small <- call_targets(mb_small, 
                         min_genes = 50)

```

The results are the same as the steps individually.

